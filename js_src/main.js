// Generated by CoffeeScript 1.9.2
(function($, C, moment, _) {
  var comment;
  C.constant = {
    DIVIDER_CHARACTER: "-",
    DICTIONARY_DIVIDER: "-",
    COMMENT_CHARACTER: "\'",
    EMPTY_DICT_STRING: "(None)",
    DIVIDER_LENGTH: 60,
    SUB_HEADER: 0,
    FUNC_HEADER: 1
  };
  C.constant.MAX_TEXT_LENGTH = C.constant.DIVIDER_LENGTH - 4;
  C.constant.DIVIDER_TEXT = Array(C.constant.DIVIDER_LENGTH + 1).join(C.constant.DIVIDER_CHARACTER);
  C.constant.DIVIDER_LINE = C.constant.COMMENT_CHARACTER + C.constant.DIVIDER_TEXT + "\n";
  C.$ = {
    output: $("#output"),
    name: $("#name"),
    assignment: $('#assignment'),
    input_radio_ctype: $('input[type=radio][name=ctype]'),
    objNameSpan: $('.obj-name-txt'),
    headerInput: $('#header-input'),
    globalContainer: $('#global-var-container'),
    localContainer: $('#local-var-container'),
    parameterContainer: $('#parameter-container'),
    returnContainer: $('#return-container'),
    subDesc: $('#sub-desc'),
    funcDesc: $('#func-desc'),
    objData: $('#obj-data'),
    programPurposeContainer: $('#program-purpose-container'),
    programPurpose: $('#program-purpose'),
    extraPurposeTxt: $('#extra-purpose-txt'),
    parameters: $('#parameters'),
    globals: $('#globals'),
    locals: $('#locals'),
    headerData: $('#header-data'),
    returnId: $('#return'),
    purpose: $('#purpose'),
    objName: $('#obj-name'),
    addGlobal: $('#add-global'),
    addLocal: $('#add-local')
  };
  C.classes = {
    VbComment: function() {
      var self;
      self = this;
      self.name = "";
      self.writtenOn = moment().format("MM/DD/YYYY");
      self.objectName = "";
      self._assignment = "";
      self.assignment = "";
      self.commentType = "";
      self.purpose = "";
      self.program_purpose = "";
      self.global_vars = [];
      self.local_vars = [];
      self.returns = new C.classes.ReturnType();
      self.parameters = [];
      self.reinitialize = function() {
        self.writtenOn = moment().format("MM/DD/YYYY");
        self.objectName = "";
        self.commentType = "";
        self.purpose = "";
        self.global_vars = [];
        self.local_vars = [];
        self.returns = new C.classes.ReturnType();
        self.parameters = [];
        self.program_purpose = "";
      };
      self.getSortedGlobals = function() {
        return _.sortBy(self.global_vars, function(obj) {
          return obj.name;
        });
      };
      self.getSortedLocals = function() {
        return _.sortBy(self.local_vars, function(obj) {
          return obj.name;
        });
      };
      self.getObjStr = function() {
        if (self.commentType === "file" || self.commentType === "main") {
          return "File";
        } else if (self.commentType === "sub") {
          return "Subprogram";
        } else if (self.commentType === "func") {
          return "Function";
        }
      };
      self.setAssignment = function(val) {
        self._assignment = val;
        if ($.isNumeric(val)) {
          self.assignment = "Assign" + val;
        } else {
          self.assignment = val;
        }
      };
      self.setPurpose = function(val) {
        self.purpose = val.replace(/(\r\n|\n|\r)/gm, "");
      };
      self.setProgramPurpose = function(val) {
        self.program_purpose = val.replace(/(\r\n|\n|\r)/gm, "");
      };
      self.getUrlKwargs = function() {
        return "?name=" + self.name + "&assignment=" + self._assignment;
      };
      self.updateUrl = function() {
        var newUrl;
        if (history.pushState) {
          newUrl = window.location.protocol + "//" + window.location.host + window.location.pathname + (self.getUrlKwargs());
          history.pushState({
            path: newUrl
          }, '', newUrl);
        }
      };
      self.getString = function() {
        var commentString, global, globals, i, j, len, len1, param, ref;
        commentString = C.constant.DIVIDER_LINE;
        if (self.commentType === 'file' || self.commentType === 'main') {
          commentString += C.utils.splitText("File Name: " + self.objectName, C.utils.padCenter);
          commentString += C.utils.splitText("Part of Project: " + self.assignment, C.utils.padCenter);
          commentString += C.constant.DIVIDER_LINE;
        } else if (self.commentType === 'sub' || self.commentType === 'func') {
          commentString += C.utils.splitText((self.getObjStr()) + " Name: " + self.objectName, C.utils.padCenter);
          commentString += C.constant.DIVIDER_LINE;
        }
        commentString += C.utils.splitText("Written By: " + self.name, C.utils.padCenter);
        commentString += C.utils.splitText("Written On: " + self.writtenOn, C.utils.padCenter);
        commentString += C.utils.DIVIDER_LINE;
        commentString += C.utils.splitText((self.getObjStr()) + " Purpose:");
        commentString += C.utils.splitText("");
        commentString += C.utils.splitText(self.purpose);
        commentString += C.constant.DIVIDER_LINE;
        if (self.commentType === 'main') {
          commentString += C.utils.splitText('Program Purpose:');
          commentString += C.utils.splitText('');
          commentString += C.utils.splitText(self.purpose);
          commentString += C.constant.DIVIDER_LINE;
          globals = self.getSortedGlobals();
          commentString += C.utils.splitText("Global Variable Dictionary (alphabetically):");
          if (globals.length > 0) {
            for (i = 0, len = globals.length; i < len; i++) {
              global = globals[i];
              commentString += C.utils.splitText(global.getString(), C.utils.padRight, true, (global.name + " - ").length);
            }
          } else {
            commentString += C.utils.splitText(C.constant.EMPTY_DICT_STRING);
          }
          commentString += C.constant.DIVIDER_LINE;
        } else if (self.commentType === 'sub' || self.commentType === 'func') {
          commentString += C.utils.splitText('Parameter Dictionary (in parameter order):');
          if (self.parameters.length > 0) {
            ref = self.parameters;
            for (j = 0, len1 = ref.length; j < len1; j++) {
              param = ref[j];
              commentString += C.utils.splitText(param.getString(), C.utils.padRight, true, (param.name + " - ").length);
            }
          } else {
            commentString += C.utils.splitText(C.constant.EMPTY_DICT_STRING);
          }
          commentString += C.constant.DIVIDER_LINE;
          if (self.commentType === 'func') {
            commentString += C.utils.splitText("Returns:");
            commentString += C.utils.splitText(self.returns.getString(), C.utils.padRight, true, (self.returns.dataType + ' - ').length);
            commentString += C.constant.DIVIDER_LINE;
          }
        }
        return commentString;
      };
    },
    Variable: function(name, description, id, var_arr) {
      var self;
      if (name == null) {
        name = "";
      }
      if (description == null) {
        description = '';
      }
      if (id == null) {
        id = '';
      }
      if (var_arr == null) {
        var_arr = '';
      }
      self = this;
      self.name = name;
      self.description = description;
      self.id = id;
      self.var_arr = var_arr;
      self.getString = function() {
        return self.name + " " + C.constant.DICTIONARY_DIVIDER + " " + self.description;
      };
      self.addDescriptionListener = function() {
        var $input;
        $input = $($("#" + self.id).find('input')[0]);
        $input.keyup(function() {
          self.description = $input.val();
          C.utils.updateOutput(comment);
        });
      };
      self.addDeleteListener = function() {
        $($("#" + self.id).find("button")[0]).on("click", function() {
          comment[self.var_arr] = comment[self.var_arr].filter(function(obj) {
            return obj.id !== self.id;
          });
          $("#" + self.id).remove();
          return C.utils.updateOutput(comment);
        });
      };
    },
    ReturnType: function(dataType, description) {
      if (dataType == null) {
        dataType = '';
      }
      if (description == null) {
        description = '';
      }
      self.dataType = dataType;
      self.description = description;
      self.getString = function() {
        return self.dataType + " " + C.constant.DICTIONARY_DIVIDER + " " + self.description;
      };
    }
  };
  C.misc = {
    queryString: (function() {
      var arr, i, len, pair, query, query_string, variable, vars;
      query = window.location.search.substring(1);
      vars = query.split("&");
      query_string = {};
      for (i = 0, len = vars.length; i < len; i++) {
        variable = vars[i];
        pair = variable.split("=");
        if (query_string[pair[0]] == null) {
          query_string[pair[0]] = decodeURIComponent(pair[1]);
        } else if (typeof query_string[pair[0]] === "string") {
          arr = [query_string[pair[0]], decodeURIComponent(pair[1])];
          query_string[pair[0]] = arr;
        } else {
          query_string[pair[0]].push(decodeURIComponent(pair[1]));
        }
      }
      return query_string;
    })()
  };
  C.utils = {
    padRight: function(stringToPad, maxLength, charToPadWith) {
      var emptySpace, padding;
      if (maxLength == null) {
        maxLength = C.constant.MAX_TEXT_LENGTH;
      }
      if (charToPadWith == null) {
        charToPadWith = " ";
      }
      emptySpace = maxLength - stringToPad.length;
      padding = Array(emptySpace + 1).join(charToPadWith);
      return stringToPad + padding;
    },
    padCenter: function(stringToPad, maxLength, charToPadWith) {
      var emptySpace, paddingLeft, paddingRight, spaceDiv2;
      if (maxLength == null) {
        maxLength = C.constant.MAX_TEXT_LENGTH;
      }
      if (charToPadWith == null) {
        charToPadWith = " ";
      }
      emptySpace = maxLength - stringToPad.length;
      spaceDiv2 = emptySpace / 2;
      if (spaceDiv2 === Number(spaceDiv2) && spaceDiv2 % 1 !== 0) {
        paddingLeft = Math.floor(spaceDiv2);
        paddingRight = Math.ceil(spaceDiv2);
      } else {
        paddingLeft = paddingRight = spaceDiv2;
      }
      return Array(paddingLeft + 1).join(charToPadWith) + stringToPad + Array(paddingRight + 1).join(charToPadWith);
    },
    getCommentLine: function(text, paddingFunction) {
      if (paddingFunction == null) {
        paddingFunction = C.utils.padRight;
      }
      return C.constant.COMMENT_CHARACTER + C.constant.DIVIDER_CHARACTER + " " + paddingFunction(text, C.constant.MAX_TEXT_LENGTH, " ") + " " + C.constant.DIVIDER_CHARACTER + "\n";
    },
    splitText: function(text, paddingFunction, indentSuccessiveLines, indentLen) {
      var firstLine, firstWord, i, idx, len, maxLength, returnText, tempLine, textToAdd, word, words;
      if (paddingFunction == null) {
        paddingFunction = C.utils.padRight;
      }
      if (indentSuccessiveLines == null) {
        indentSuccessiveLines = false;
      }
      if (indentLen == null) {
        indentLen = 5;
      }
      maxLength = C.constant.MAX_TEXT_LENGTH;
      if (text.length > maxLength) {
        words = text.split(" ");
        tempLine = returnText = "";
        for (idx = i = 0, len = words.length; i < len; idx = ++i) {
          word = words[idx];
          textToAdd = " " + word;
          firstWord = tempLine.length === 0;
          firstLine = idx === 0;
          if (!firstWord && (tempLine.length + textToAdd.length) > maxLength) {
            returnText += C.utils.getCommentLine(tempLine, paddingFunction);
            tempLine = "";
            if (indentSuccessiveLines && !firstLine) {
              tempLine += Array(indentLen + 1).join(" ");
            }
            tempLine += word;
          } else if (firstWord) {
            if (indentSuccessiveLines && !firstLine) {
              tempLine += Array(indentLen + 1).join(" ");
            }
            tempLine += word;
          } else {
            tempLine += textToAdd;
          }
        }
      } else {
        returnText = C.utils.getCommentLine(text, paddingFunction);
      }
      return returnText;
    },
    updateOutput: function(comment) {
      C.$.output.val(comment.getString());
    },
    removeElementFromArray: function(array) {
      var L, a, ax, what;
      a = arguments;
      L = array.length;
      while (L > 1 && array.length) {
        what = a[--L];
        while ((ax = array.indexOf(what)) !== -1) {
          array.splice(ax, 1);
        }
      }
      return array;
    },
    parseHeaderParameters: function(parameterString) {
      var i, len, param, paramName, paramSplit, paramStrings, params_to_return;
      paramStrings = C.utils.removeElementFromArray(parameterString.split(", "), "");
      params_to_return = [];
      for (i = 0, len = paramStrings.length; i < len; i++) {
        param = paramStrings[i];
        paramSplit = param.split(" As ");
        paramName = paramSplit[0];
        params_to_return.push(new C.classes.Variable(paramName));
      }
      return params_to_return;
    },
    parseHeader: function(header, headerType) {
      var getReturnType, headerName, initialHeaderSplit, parameterString, parameters, returnType;
      getReturnType = headerType === C.constant.FUNC_HEADER;
      initialHeaderSplit = header.split("(");
      parameterString = initialHeaderSplit[1].split(")")[0];
      headerName = initialHeaderSplit[0].split(" ")[1];
      returnType = getReturnType ? header.split(" As ").pop() : null;
      parameters = C.utils.parseHeaderParameters(parameterString);
      return {
        name: headerName,
        type: returnType,
        parameters: parameters
      };
    },
    parseSubHeader: function(header) {
      return C.utils.parseHeader(header, C.constant.SUB_HEADER);
    },
    parseFuncHeader: function(header) {
      return C.utils.parseHeader(header, C.constant.FUNC_HEADER);
    },
    randomString: function(length) {
      var chars, i, ref, result, z;
      if (length == null) {
        length = 16;
      }
      chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
      result = "";
      for (z = i = ref = length; ref <= 0 ? i <= 0 : i >= 0; z = ref <= 0 ? ++i : --i) {
        result += chars[Math.floor(Math.random() * chars.length)];
      }
      return result;
    }
  };
  comment = new C.classes.VbComment();
  if (C.misc.queryString.name != null) {
    comment.name = C.misc.queryString.name;
    C.$.name.val(comment.name);
  }
  if (C.misc.queryString.assignment != null) {
    comment.setAssignment(C.misc.queryString.assignment);
    C.$.assignment.val(C.misc.queryString.assignment);
  }
  C.$.input_radio_ctype.change(function() {
    comment.reinitialize();
    comment.commentType = this.value;
    if (this.value === 'file' || this.value === 'main') {
      C.$.objNameSpan.html('File');
      C.$.headerInput.hide();
      C.$.returnContainer.hide();
      if (this.value === 'file') {
        C.$.globalContainer.hide();
        C.$.programPurposeContainer.hide();
        C.$.extraPurposeTxt.html("");
      } else {
        C.$.programPurposeContainer.show();
        C.$.globalContainer.show();
        C.$.extraPurposeTxt.html("File ");
      }
    } else if (this.value === 'sub') {
      C.$.objNameSpan.html("Subprogram");
      C.$.headerInput.show();
      C.$.globalContainer.hide();
      C.$.returnContainer.hide();
      C.$.subDesc.show();
      C.$.funcDesc.hide();
    } else if (this.value === 'func') {
      C.$.objNameSpan.html("Function");
      C.$.headerInput.show();
      C.$.globalContainer.hide();
      C.$.subDesc.hide();
      C.$.funcDesc.show();
    }
    if (this.value === 'sub' || this.value === 'func') {
      C.$.objData.hide();
      C.$.localContainer.show();
      C.$.programPurposeContainer.hide();
      C.$.extraPurposeTxt.html("");
    } else {
      C.$.objData.show();
      C.$.parameterContainer.hide();
      C.$.localContainer.hide();
    }
    C.$.parameters.find('tr').remove();
    C.$.globals.find('tr').remove();
    C.$.locals.find('tr').remove();
    C.$.headerData.val("");
    C.$.returnId.val("");
    C.$.purpose.val("");
    C.$.objName.val("");
    C.$.programPurpose.val("");
    C.utils.updateOutput(comment);
  });
  C.$.name.keyup(function() {
    comment.name = C.$.name.val();
    C.utils.updateOutput(comment);
    comment.updateUrl();
  });
  C.$.assignment.keyup(function() {
    comment.setAssignment(C.$.assignment.val());
    C.utils.updateOutput(comment);
    comment.updateUrl();
  });
  C.$.objName.keyup(function() {
    comment.objectName = C.$.objName.val();
    C.utils.updateOutput(comment);
  });
  C.$.purpose.keyup(function() {
    comment.setPurpose(C.$.purpose.val());
    C.utils.updateOutput(comment);
  });
  C.$.headerData.keyup(function() {
    var descCol, headerDict, i, len, nameCol, param, parseFunc, ref, row, table;
    try {
      parseFunc = comment.commentType === 'sub' ? C.utils.parseSubHeader : C.utils.parseFuncHeader;
      headerDict = parseFunc(C.$.headerData.val());
      table = document.getElementById('parameters');
      C.$.parameters.find('tr').remove();
      comment.parameters = headerDict.parameters;
      comment.returns = new C.classes.ReturnType(headerDict.type);
      comment.objectName = headerDict.name;
      C.$.headerData.css("color", "black");
      ref = comment.parameters;
      for (i = 0, len = ref.length; i < len; i++) {
        param = ref[i];
        param.id = C.utils.randomString();
        row = table.insertRow(-1);
        nameCol = row.insertCell(0);
        descCol = row.insertCell(1);
        $(row).attr('id', param.id);
        nameCol.innerHTML = param.name;
        descCol = '<input type="text" class="parameter-desc">';
        param.addDescriptionListener();
      }
      C.$.parameterContainer.show();
      if (comment.commentType === 'func') {
        C.$.returnContainer.show();
      }
    } catch (_error) {
      comment.parameters = [];
      C.$.headerData.css("color", "red");
      C.$.parameterContainer.hide();
      C.$.returnContainer.hide();
    } finally {
      C.utils.updateOutput(comment);
    }
  });
  C.$.addGlobal.on('click', function() {
    var deleteBtnCol, descCol, global, globalDesc, globalId, globalName, nameCol, row, table;
    globalName = prompt('What is the name of the global variable?');
    globalDesc = prompt('Please describe the global variable:');
    globalId = C.utils.randomString();
    global = new C.classes.Variable(globalName, globalDesc, globalId, 'global_vars');
    table = document.getElementById('globals');
    row = table.insertRow(-1);
    nameCol = row.insertCell(0);
    descCol = row.insertCell(1);
    deleteBtnCol = row.insertCell(2);
    comment.global_vars.push(global);
    nameCol.innerHTML = global.name;
    descCol.innerHTML = global.description;
    deleteBtnCol.outerHTML = '<button class="btn btn-danger-outline"><i class="fa fa-trash-o"></i></button>';
    $(row).attr('id', globalId);
    global.addDeleteListener();
    C.utils.updateOutput(comment);
  });
  C.$.addLocal.on('click', function() {
    var deleteBtnCol, descCol, local, localDesc, localId, localName, nameCol, row, table;
    localName = prompt('What is the name of the local variable?');
    localDesc = prompt('Please describe the local variable:');
    localId = C.utils.randomString();
    local = new C.classes.Variable(localName, localDesc, localId, 'local_vars');
    table = document.getElementById('locals');
    row = table.insertRow(-1);
    nameCol = row.insertCell(0);
    descCol = row.insertCell(1);
    deleteBtnCol = row.insertCell(2);
    comment.local_vars.push(local);
    nameCol.innerHTML = local.name;
    descCol.innerHTML = local.description;
    deleteBtnCol.outerHTML = '<button class="btn btn-danger-outline"><i class="fa fa-trash-o"></i></button>';
    $(row).attr('id', localId);
    local.addDeleteListener();
    C.utils.updateOutput(comment);
  });
  C.$.returnId.keyup(function() {
    comment.returns.description = C.$.returnId.val();
    C.utils.updateOutput(comment);
  });
  C.$.programPurpose.keyup(function() {
    comment.setProgramPurpose(C.$.programPurpose.val());
    C.utils.updateOutput(comment);
  });
  return C.utils.updateOutput(comment);
})(jQuery, VbComment, moment, _);

//# sourceMappingURL=main.js.map
